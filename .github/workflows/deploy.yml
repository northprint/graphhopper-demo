name: Deploy to AWS

on:
  push:
    branches: [ main ]
  workflow_dispatch:

env:
  AWS_REGION: ap-northeast-1
  ECR_REPOSITORY: graphhopper-demo

jobs:
  build-and-push-ecr:
    name: Build and Push Docker Image to ECR
    runs-on: ubuntu-latest
    outputs:
      image-tag: ${{ steps.image.outputs.tag }}
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
    
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}
    
    - name: Login to Amazon ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v2
    
    - name: Check if ECR repository exists
      id: check-ecr
      run: |
        echo "Checking if ECR repository $ECR_REPOSITORY exists..."
        if aws ecr describe-repositories --repository-names $ECR_REPOSITORY 2>/dev/null; then
          echo "ECR repository exists"
          echo "exists=true" >> $GITHUB_OUTPUT
        else
          echo "ECR repository does not exist"
          echo "exists=false" >> $GITHUB_OUTPUT
          exit 1
        fi
    
    - name: Build, tag, and push Docker image to Amazon ECR
      id: image
      env:
        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        IMAGE_TAG: ${{ github.sha }}
      run: |
        echo "Building Docker image..."
        # Build from project root to access data directory
        docker build -f services/graphhopper/Dockerfile.production -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG .
        
        echo "Pushing image with tag: $IMAGE_TAG"
        docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
        
        echo "Tagging and pushing as latest..."
        docker tag $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG $ECR_REGISTRY/$ECR_REPOSITORY:latest
        docker push $ECR_REGISTRY/$ECR_REPOSITORY:latest
        
        echo "tag=$IMAGE_TAG" >> $GITHUB_OUTPUT
        echo "Docker image successfully pushed to ECR"

  deploy-infrastructure:
    name: Deploy Infrastructure with AWS CDK
    runs-on: ubuntu-latest
    needs: build-and-push-ecr
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
    
    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '20'
    
    - name: Setup pnpm
      uses: pnpm/action-setup@v2
      with:
        version: 9
    
    - name: Install dependencies from project root
      run: |
        echo "Installing dependencies with pnpm workspaces..."
        pnpm install
    
    - name: Install AWS CDK globally
      run: |
        echo "Installing AWS CDK CLI..."
        npm install -g aws-cdk
        cdk --version
    
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}
    
    - name: Deploy CDK stacks
      run: |
        cd infrastructure
        echo "Deploying CDK stacks..."
        cdk deploy --all --require-approval never --verbose
      env:
        CDK_DEFAULT_ACCOUNT: ${{ secrets.AWS_ACCOUNT_ID }}
        CDK_DEFAULT_REGION: ${{ env.AWS_REGION }}

  update-ecs-service:
    name: Update ECS Service with New Image
    runs-on: ubuntu-latest
    needs: [build-and-push-ecr, deploy-infrastructure]
    
    steps:
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}
    
    - name: Check if ECS service exists
      id: check-service
      run: |
        echo "Checking if ECS service exists..."
        if aws ecs describe-services --cluster graphhopper-cluster --services graphhopper-api --query 'services[0].status' --output text 2>/dev/null | grep -q "ACTIVE"; then
          echo "ECS service is active"
          echo "exists=true" >> $GITHUB_OUTPUT
        else
          echo "ECS service does not exist or is not active"
          echo "exists=false" >> $GITHUB_OUTPUT
          exit 1
        fi
    
    - name: Force new deployment
      if: steps.check-service.outputs.exists == 'true'
      run: |
        echo "Forcing new deployment of ECS service..."
        aws ecs update-service \
          --cluster graphhopper-cluster \
          --service graphhopper-api \
          --force-new-deployment \
          --region ${{ env.AWS_REGION }}
        echo "ECS service update initiated"

  build-and-deploy-frontend:
    name: Build and Deploy Frontend to S3
    runs-on: ubuntu-latest
    needs: deploy-infrastructure
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
    
    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '20'
    
    - name: Setup pnpm
      uses: pnpm/action-setup@v2
      with:
        version: 9
    
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}
    
    - name: Get API URL from GraphHopperApiStack
      id: get-api-url
      run: |
        echo "Getting API URL from GraphHopperApiStack..."
        API_URL=$(aws cloudformation describe-stacks \
          --stack-name GraphHopperApiStack \
          --query "Stacks[0].Outputs[?OutputKey=='AlbUrl'].OutputValue" \
          --output text 2>/dev/null)
        
        if [ -z "$API_URL" ] || [ "$API_URL" == "None" ]; then
          echo "Error: Could not retrieve API URL from stack"
          exit 1
        fi
        
        echo "API URL: $API_URL"
        echo "api_url=$API_URL" >> $GITHUB_OUTPUT
    
    - name: Install dependencies from project root
      run: |
        echo "Installing dependencies with pnpm workspaces..."
        pnpm install
    
    - name: Build frontend with API URL
      run: |
        cd apps/web
        echo "Building frontend with API URL: ${{ steps.get-api-url.outputs.api_url }}"
        echo "PUBLIC_GRAPHHOPPER_URL=${{ steps.get-api-url.outputs.api_url }}" > .env.production
        pnpm build
        
        # Verify build output
        if [ ! -d "build" ]; then
          echo "Error: Build directory not found"
          exit 1
        fi
        
        echo "Frontend build completed successfully"
    
    - name: Get S3 bucket name
      id: get-bucket
      run: |
        echo "Getting S3 bucket name from GraphHopperFrontendStack..."
        BUCKET_NAME=$(aws cloudformation describe-stacks \
          --stack-name GraphHopperFrontendStack \
          --query "Stacks[0].Outputs[?OutputKey=='BucketName'].OutputValue" \
          --output text 2>/dev/null)
        
        if [ -z "$BUCKET_NAME" ] || [ "$BUCKET_NAME" == "None" ]; then
          echo "Error: Could not retrieve bucket name from stack"
          exit 1
        fi
        
        echo "S3 Bucket: $BUCKET_NAME"
        echo "bucket_name=$BUCKET_NAME" >> $GITHUB_OUTPUT
    
    - name: Deploy frontend to S3
      run: |
        echo "Deploying frontend to S3 bucket: ${{ steps.get-bucket.outputs.bucket_name }}"
        aws s3 sync apps/web/build s3://${{ steps.get-bucket.outputs.bucket_name }} --delete
        echo "Frontend deployed to S3 successfully"
    
    - name: Get CloudFront distribution ID
      id: get-distribution
      run: |
        echo "Getting CloudFront distribution ID..."
        DISTRIBUTION_ID=$(aws cloudformation describe-stacks \
          --stack-name GraphHopperFrontendStack \
          --query "Stacks[0].Outputs[?OutputKey=='DistributionId'].OutputValue" \
          --output text 2>/dev/null)
        
        if [ -z "$DISTRIBUTION_ID" ] || [ "$DISTRIBUTION_ID" == "None" ]; then
          echo "Error: Could not retrieve distribution ID from stack"
          exit 1
        fi
        
        echo "CloudFront Distribution ID: $DISTRIBUTION_ID"
        echo "distribution_id=$DISTRIBUTION_ID" >> $GITHUB_OUTPUT
    
    - name: Invalidate CloudFront cache
      run: |
        echo "Creating CloudFront invalidation..."
        INVALIDATION_ID=$(aws cloudfront create-invalidation \
          --distribution-id ${{ steps.get-distribution.outputs.distribution_id }} \
          --paths "/*" \
          --query 'Invalidation.Id' \
          --output text)
        
        echo "CloudFront invalidation created with ID: $INVALIDATION_ID"
    
    - name: Get CloudFront URL
      run: |
        echo "Getting CloudFront distribution URL..."
        CF_URL=$(aws cloudformation describe-stacks \
          --stack-name GraphHopperFrontendStack \
          --query "Stacks[0].Outputs[?OutputKey=='DistributionUrl'].OutputValue" \
          --output text 2>/dev/null)
        
        if [ ! -z "$CF_URL" ] && [ "$CF_URL" != "None" ]; then
          echo "Frontend URL: $CF_URL"
        fi